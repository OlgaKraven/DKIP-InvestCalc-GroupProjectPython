# Производительность и оптимизация (Performance)

Проект: **InvestCalc — Инвестиционный аналитик ИС**  
Версия документа: 1.0  
Дата: `<указать>`

---

## 1. Назначение документа

Документ описывает:

- ожидаемые характеристики производительности InvestCalc;
- основные потенциальные узкие места;
- реализованные в проекте решения, влияющие на скорость работы;
- рекомендации по дальнейшей оптимизации.

InvestCalc — учебный сервис с относительно простыми расчётами и JSON-хранилищем. Тем не менее, базовые вопросы производительности и масштабируемости здесь тоже учитываются.

---

## 2. Целевой профиль нагрузки

В учебной конфигурации:

- **Число пользователей:** до 5–20 человек одновременно (студенты/преподаватель).
- **Интенсивность запросов:** обычно единичные или десятки запросов в минуту.
- **Размер данных:**
  - количество сценариев в `scenarios.json` — десятки или сотни записей;
  - размер файла — до нескольких сотен килобайт / единиц мегабайт.

Вывод:  
на данном этапе **производительность не является критическим фактором**, однако проект спроектирован так, чтобы его можно было масштабировать.

---

## 3. Основные операции и их стоимость

### 3.1. Расчёт показателей (`calculate_metrics`)

- Операции: несколько арифметических выражений (TCO, ROI, Payback).
- Ассимптотика: **O(1)** по времени и памяти.
- Узких мест не ожидается, даже при сотнях/тысячах вызовов в секунду.

### 3.2. Анализ чувствительности (`run_sensitivity`)

- Операции:
  - один базовый расчёт,
  - по два дополнительных расчёта на каждый параметр в списке `parameters`.
- Ассимптотика:
  - **O(n)** по количеству анализируемых параметров,
  - где `n` обычно от 1 до 3 (CAPEX, OPEX, эффекты).
- Даже при `n=10` стоимость невысока.

### 3.3. Работа с JSON-хранилищем

- Каждый вызов:
  - читает целиком `scenarios.json` (для чтения списка или поиска),
  - перезаписывает файл целиком при сохранении.
- Ассимптотика:
  - чтение: **O(N)**, где `N` — число сценариев;
  - запись: **O(N)**.
- При учебном ограничении `N` (до сотен) задержки незначительны (миллисекунды).

---

## 4. Потенциальные узкие места

1. **Файл `data/scenarios.json` как единственная точка хранения**
   - полное чтение/запись файла при каждой операции;
   - отсутствие блокировок при параллельной записи;
   - потенциальное повреждение файла при прерывании записи.

2. **Отсутствие кеширования**
   - при большом количестве чтений сценариев (например, дашборд) могли бы использоваться кеши в памяти.

3. **Отсутствие асинхронного I/O**
   - чтение/запись файла выполняются синхронно;
   - при большом количестве запросов это может создавать блокировки event-loop.

На учебном стенде эти ограничения не критичны, но их нужно учитывать при описании архитектуры и в отчёте.

---

## 5. Реализованные подходы

### 5.1. Простота и предсказуемость логики

- Расчёты реализованы в чистых функциях без внешних зависимостей.
- Нет тяжёлых библиотек для вычислений.
- Логика не зависит от сетевых запросов/внешних API.

Это делает время выполнения **очень стабильным** и легко прогнозируемым.

### 5.2. Минимизация сложности моделей

- Модели `InvestInput`, `InvestResult`, `ScenarioDetail` компактны.
- Нет глубоких вложенных структур и больших массивов.
- Это снижает накладные расходы на сериализацию/десериализацию.

### 5.3. Ограниченный размер JSON-файла

- Проект подразумевает учебное использование, поэтому файл `scenarios.json` по умолчанию небольшой.
- Отдельного механизма ротации/шардинга файлов **нет** — как осознанное упрощение.

---

## 6. Рекомендации по измерению производительности

Для лабораторных / учебных задач можно:

1. Использовать встроенный профайлинг:
   - простой замер времени выполнения отдельных функций (`time.perf_counter`).
2. Измерять:
   - время ответа `/api/v1/calc`,
   - время чтения/записи сценариев,
   - зависимость времени от количества сценариев в `scenarios.json`.

Пример (черновая идея для отчёта):

- измерить время обработки 1000 последовательных запросов `/calc` через `locust` / `ab` / `wrk`,
- измерить время чтения/записи 10 / 100 / 1000 сценариев.

---

## 7. Направления оптимизации (для будущих версий)

Если проект будет развиваться **за рамки учебного**, возможны следующие шаги:

### 7.1. Переход с JSON на БД

- Использовать SQLite/PostgreSQL вместо `scenarios.json`.
- Ассимптотика операций:
  - поиск сценария → `O(log N)` или `O(1)` (индекс),
  - записи не требуют перезаписи всего массива.

### 7.2. Асинхронный I/O

- Перевести сервис на `async`-операции работы с диском/БД.
- Дать возможность обслуживать больше запросов за счёт неблокирующего ввода-вывода.

### 7.3. Кеширование

- На уровне приложения:
  - кешировать списки сценариев,
  - сбрасывать кеш при изменении.
- На уровне внешних систем:
  - использовать Redis / in-memory кеш.

### 7.4. Горизонтальное масштабирование

- Развёртывание нескольких копий приложения за балансировщиком.
- Перенос хранения на общую БД/хранилище.

---

## 8. Практическое использование в учебном курсе

В отчётности по проекту раздел “Производительность” может включать:

1. Описание текущей реализации (как в этом документе).  
2. Таблицу с **замерами времени** выполнения нескольких типовых операций.  
3. Список потенциальных улучшений и их влияние на:
   - производительность,
   - сложность разработки,
   - стоимость поддержки.

---

## 9. Связанные документы

- `docs/03-architecture/performance-risks.md` (если есть)  
- `docs/04-data-model/db-schema.md`  
- `docs/06-implementation/data-access.md`  
- `docs/06-implementation/business-logic.md`  
- `docs/06-implementation/api-internal.md`  
 
