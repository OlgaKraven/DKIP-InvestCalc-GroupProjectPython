# ADR-04 — Использование Pydantic для моделей и валидации данных
Дата: 2025-01-01  
Статус: Принято

---

## 1. Контекст

Система InvestCalc принимает и обрабатывает структурированные данные, используемые в финансовых расчётах:

- CAPEX  
- OPEX  
- период анализа  
- экономический эффект  
- параметры анализа чувствительности  
- сценарии (JSON)  

Эти данные поступают от:
- пользователей,
- внешних систем,
- файлов сценариев.

Для обеспечения корректной работы API необходимо гарантировать, что входные данные удовлетворяют требованиям:

- числовые типы,
- корректные диапазоны (CAPEX ≥ 0),
- обязательные поля,
- отсутствие некорректных типов,
- предсказуемая структура JSON.

Требуется выбрать стандартный механизм **валидации и типизации данных**.

---

## 2. Решение

Принято решение использовать:

## ✔ **Pydantic (v2) как основу моделей данных и системы валидации**

Pydantic применяется во всех уровнях API:

- входные модели (InputData),
- модель анализа чувствительности,
- модели результатов вычислений,
- модели сценариев.

---

## 3. Обоснование выбора

## 3.1. Строгая типизация
Pydantic обеспечивает:
- проверку типов в рантайме,
- приведение типов (например, строк → число),
- детализированные сообщения об ошибках.

## 3.2. Интеграция с FastAPI
FastAPI использует Pydantic модели:

- в параметрах эндпоинтов,
- валидацию данных,
- автоматическую документацию OpenAPI.

Это минимизирует количество самописной логики.

## 3.3. Автоматическая документация
Pydantic-модели автоматически появляются в:
- Swagger UI,
- Redoc,
- OpenAPI json.

## 3.4. Безопасность
Pydantic исключает:
- произвольные данные,
- нарушающие типы,
- недостающие поля,
- отрицательные значения (если задано ограничение).

## 3.5. Производительность
Pydantic — один из самых быстрых валидаторов Python.

## 3.6. Поддержка тестирования
pytest легко взаимодействует с Pydantic моделями.

---

## 4. Альтернативы

## 4.1. Ручная проверка данных
**Отклонено**
- громоздко;
- увеличивает вероятность ошибок;
- невозможность повторного использования;
- нет интеграции с OpenAPI.

## 4.2. Marshmallow
**Отклонено**
- избыточен для FastAPI;
- хуже интеграция с Swagger;
- нет автогенерации схем.

## 4.3. Dataclasses + ручная валидация
**Отклонено**
- dataclass не выполняет проверку типов,
- большая часть логики ложится на разработчика.

## 4.4. Сырые JSON-структуры (dict)
**Отклонено**
- ненадёжно,
- высокая вероятность ошибок,
- отсутствие документации модели.

---

## 5. Последствия

## Положительные:
- предсказуемость входных структур;
- удобная автодокументация;
- снижение количества ошибок;
- снижение когнитивной нагрузки на студентов;
- чистый код в сервисном слое.

## Негативные:
- требуется изучить синтаксис Pydantic (небольшой порог входа);
- сложные вложенные модели требуют дополнительного внимания.

---

## 6. Примеры использования в проекте

## Пример входной модели

```python
class InvestmentInput(BaseModel):
    capex: float = Field(ge=0)
    opex: float = Field(ge=0)
    period: int = Field(ge=1)
    effect: float = Field(ge=0)
```

## Пример результата

```python
class CalcResult(BaseModel):
    tco: float
    roi: float
    payback: float | None
    is_profitable: bool
```

---

## 7. Связанные ADR

* ADR-01 — Технологический стек
* ADR-03 — Структура каталогов
* ADR-05 — Выделение сервисного слоя
* ADR-11 — Безопасность API
* ADR-14 — Путь расширения архитектуры



