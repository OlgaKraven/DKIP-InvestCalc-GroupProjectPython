# ADR-06 — Stateless архитектура InvestCalc

Дата: 2025-01-01  
Статус: Принято

---

## 1. Контекст

Система InvestCalc предназначена для:
- выполнения расчётов экономической эффективности,
- анализа чувствительности,
- сравнения сценариев,
- формирования отчётов.

В проекте **нет необходимости хранить историю запросов, пользователей или промежуточные данные**.  
Все необходимые данные передаются в запросах (`POST /calculate`, `POST /sensitivity` и др.).

Также проект ориентирован на:
- лёгкую контейнеризацию,
- работу без БД,
- возможность горизонтального масштабирования,
- прозрачное поведение API,
- минимизацию инфраструктурных зависимостей.

Возникает вопрос:  
**Нужно ли хранить состояние между запросами, или система должна быть stateless?**

---

## 2. Решение

Принято решение:  

## ✔ **InvestCalc работает по принципу Stateless Architecture**

То есть:
- ни одно значение не хранится на сервере между вызовами;
- каждая операция независима от предыдущих;
- API рассчитывает результат только на основе входных данных.

---

## 3. Обоснование

## 3.1. Соответствие REST-принципам
REST API должен быть stateless:
- каждый запрос самодостаточен,
- не требуется состояние на стороне сервера.

## 3.2. Упрощение DevOps и контейнеризации
Stateless-сервис:
- проще масштабировать,
- легко запускать в нескольких контейнерах,
- можно балансировать между экземплярами.

## 3.3. Отсутствие зависимости от БД
Проект учебный и не требует:
- хранения пользователей,
- хранения сценариев в таблицах,
- логирования в БД.

Это снижает сложность.

## 3.4. Повышение стабильности
При перезапуске контейнера состояние не теряется, потому что его нет.

## 3.5. Высокая безопасность
Отсутствие хранимых данных исключает утечки:
- персональных данных,
- сценариев,
- результатов расчётов.

## 3.6. Простота тестирования
Каждый тест:
- независим,
- воспроизводим.

---

## 4. Альтернативы

## 4.1. Хранение состояния в памяти (in-memory)
**Отклонено**  
Причины:
- невозможно масштабировать несколько контейнеров,
- данные теряются при перезапуске,
- исключает балансировку нагрузки.

## 4.2. Использование базы данных
**Отклонено**  
Причины:
- избыточно для текущей учебной задачи,
- требует дополнительных ADR, моделей, миграций,
- усложняет проект.

В будущем возможно как расширение (см. ADR-14).

## 4.3. Сессионная архитектура
**Отклонено**  
Причины:
- противоречит REST,
- усложняет API,
- требует хранения состояния пользователей.

---

## 5. Последствия

## Положительные:
- простота архитектуры,
- отличная масштабируемость,
- лёгкая интеграция с Docker/Kubernetes,
- высокая надёжность,
- отсутствие зависимости от БД,
- безопасность выше (нет хранимых данных),
- тестируемость выше.

## Негативные:
- при расширении системы (например, если появятся пользователи или отчёты) придётся менять модель.

---

## 6. Примеры в коде

## API → Stateless

```python
@router.post("/calculate")
def calculate(data: InvestmentInput):
    return invest_service.calculate_all(data)
```

Каждый вызов — полностью независимый.

## Нет глобального состояния:

```python
## Никаких global переменных, сессий или cached results
```

---

## 7. Связанные ADR

* ADR-01 — Технологический стек
* ADR-03 — Структура каталогов
* ADR-05 — Service Layer
* ADR-12 — Масштабирование
* ADR-14 — Путь расширения архитектуры
 